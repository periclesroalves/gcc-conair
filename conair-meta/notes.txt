---------
- General
---------

- TODO: Document pass in trunk/gcc/doc/invoke.texi
- TODO: Remember to verify todos for after pass (e.g., clean_ssa, which requires
  marking new names to be done).

- I coudn't find a way to verify if a function comes from a library, so I wasn't
  able to verify if the user may have overwritten functions like __assert_rtn
  and pthreads_lock.
   . Since this coudn't be verified, newly inserted assertion failure block will
   have the original dereference block as a successor, as the user may redefine
   __assert_rtn or __assert_fail not to exit.
  TODO: currently we implement assertion failures as calls to __builtin_trap.
  However, the original assert() does nothing when NDEBUG is defined, and so
  should our implementaation.

- I assume that every pointer dereference is represented as the rhs or lhs of a
  single rhs assignment. In other stages of the CFG this may not be true. Other
  than that, the dereferenced address must be hold by an SSA name, so that we
  can safely test it before the actual dereference (no side effect garanteed).
  NOTE: arrays declared locally with fixed size are handled with special
    indexing read and write instructions. Currently this instructions are not
    being considered for pointer dereference instrumentation. We must also
    handle this in a different way when looking for idempotent regions.
  TODO: In addition, we must consider builtin functions that may dereference an
    argument: maybe handle them by hand.

- TODO: improve graph-check to verify the existence of assertion failure calls
  (maybe create one version of pointer testing for output testing and another
  for segfault avoidance testing).


--------------------
- Idempotent regions
--------------------

GCC has two types of SSA operands: real and virtual. Real operands are scalar
local variables with location known at all times and virtual operands are
references to globals, aliased variables, arrays, etc. To what I understand,
when looking for idempotent regions, we must consider the following:
  - Write to virtual operands (virtual definitions/stores) are
    idempotent-destroying instructions, mainly because they may change data
    exposed to another threads.
  - Assignments to real operands:
     . SSA guarantees no static write after read, however copy insertion for
     phi elimination will eventually insert problematic variable reassignments
     in loops.
     . Variables are not guaranteed to be in registers all times, therefore the
     compiler must not reuse the same stack slot for two variables (probably
     disable the stack coloring pass) (-fno-ira-share-spill-slots).
     . Register restoring solves the problem of potential assignment of two
     different variables to the same register.
     . Dynamic rewrites ...
       . Have to find an algorithm to detect potential clobber dependences in
       loops:
        . Phis that imply in read before reassignment always occour in the head of
        a loop.
        . A copy instruction will be inserted at the end of all blocks that
        define the operands of the phi instruction that defines the variable.
        . ? Therefore every assignment of a operand of the phi can be considered
        a reassignment of the variable that the phi instruction defines.
        . !!! Shan gave the idea of, for every loop, in case there's no
        idempotency-destroying operation inside the loop, when create a memory
        checkpoint for conflicting variables right before the loop starts, so we
        can always recover the whole loop. In case there is a
        idempotency-destroying operation in the loop body, we simply insert a
        reexecution point in the beginning of the loop header.

!!! if a idemp begin point is a phi instruction, then the intrumentation must be
inserted at the beginning of the block (after phis, before statements).
