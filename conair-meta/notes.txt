
- General
---------

- TODO: Document pass in trunk/gcc/doc/invoke.texi
- TODO: Remember to verify todos for after pass (e.g., clean_ssa, which requires
  marking new names to be done).

- I coudn't find a way to verify if a function comes from a library, so I wasn't
  able to verify if the user may have overwritten functions like __assert_rtn
  and pthreads_lock.
   . Since this coudn't be verified, newly inserted assertion failure block will
   have the original dereference block as a successor, as the user may redefine
   __assert_rtn or __assert_fail not to exit.
  TODO: currently we implement assertion failures as calls to __builtin_trap.
  However, the original assert() does nothing when NDEBUG is defined, and so
  should our implementaation.

- I assume that every pointer dereference is represented as the rhs or lhs of a
  single rhs assignment. In other stages of the CFG this may not be true. Other
  than that, the dereferenced address must be hold by an SSA name, so that we
  can safely test it before the actual dereference (no side effect garanteed).
  NOTE: arrays declared locally with fixed size are handled with special
    indexing read and write instructions. Currently this instructions are not
    being considered for pointer dereference instrumentation. We must also
    handle this in a different way when looking for idempotent regions.
  TODO: In addition, we must consider builtin functions that may dereference an
    argument: maybe handle them by hand.

- TODO: improve graph-check to verify the existence of assertion failure calls
  (maybe create one version of pointer testing for output testing and another
  for segfault avoidance testing).


--------------------
- Idempotent regions
--------------------

GCC has two types of SSA operands: real and virtual. Real operands are scalar
local variables with location known at all times and virtual operands are
references to globals, aliased variables, arrays, etc. To what I understand,
when looking for idempotent regions, we must consider the following:
  - Write to virtual operands (virtual definitions/stores) are
    idempotent-destroying instructions, mainly because they may change data
    exposed to another threads.
  - Assignments to real operands:
    . SSA guarantees no static write after read, however copy insertion for
    phi elimination will eventually insert problematic variable reassignments
    in loops.
    . Variables are not guaranteed to be in registers all times, therefore the
    compiler must not reuse the same stack slot for two variables (probably
    disable the stack coloring pass) (-fno-ira-share-spill-slots).
    TODO: try to disable stack coloring only for variables in idempotent
    regions.
    . Register restoring solves the problem of potential assignment of two
    different variables to the same register.
    . Dynamic rewrites - possible algorithm:
      . When visiting a phi in a loop head, if at least one of its operands are
      assigned within the loop, insert a stack checkpoint for every operand
      defined outside the loop.
      !!! Take care so the block is not generated when the loop has no phis.
      !!! This is useless when there are no paths in the loop that do not cross
      a cut.
      !!! Verify if the checkpoint block is not removed by future passes.
      . Every time a cut is inserted in a loop, insert the loop id in cutLoops.
      . When visiting * = V inside a loop:
        . if V is defined by a phi in the loop head AND at least one of the phi
        operands are assigned inside the loop:
          . if the loop was already cut, insert a cut after * = V and don't
          push its predecessors.
          . otherwise, add * = V to potentiallyHarmfulReads.
      . at the end of the backwards BFS, iterate over potentiallyHarmfulReads
      inserting cuts after reads whose loops where cut (are in cutLoops).
      !!! remember that loops may have outer loops and bb->father_loop
      references only the innermost one.


!!! if a idemp begin point is a phi instruction, then the intrumentation must be
inserted at the beginning of the block (after phis, before statements).
!!! Idempotency analysis is run for each failure site. Take care so we do not
insert a reexection point in the same place more than once. Maybe we could
maintain a set of already analysed blocks. We would still have the problem of
blocks that were only analysed from somewhere in the middle. Verify how this
behaves when inserting cuts for dynamic variables in loops. Another option would
be simply to analyse everything again, and let the caller handle repeated
identified reexecution points (problably mantaining a set of reexection points
and instrumenting them in a different pass (after analysing and instrumenting
all failure sites)).
!!! it looks like simple induction variables are not in SSA form. Verify that.
